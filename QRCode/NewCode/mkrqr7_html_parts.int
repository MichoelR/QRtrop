mkrqr7	; mkr 07/31/2025; kriah (קריה), trope (טעמים), and syntax - various queries
	; HTML output version with separated syntax parts in spans
	;
findMismatch ; Find mismatches between trope (lvls) and syntax (fslvls) trees in ^torah2
 n chars,NONLETTERS
 s U="^"
 m chars=^mkr4("chars")
 s NONLETTERS="" f i=1425:1:1469,1471:1:1479 s NONLETTERS=NONLETTERS_$c(i) ; all characters that aren't aleph - tav
 ;f bookn=1:1:35 d
 f bookn=1 d	; DEBUGGING
 . f versen=1:1 q:'$d(^torah2(bookn,versen))  d findMismatchVerse(bookn,versen)
 q
 ;
findMismatchVerse(bookn,versen) ; Find mismatches for a specific verse
 n lvls,fslvls,lvl1,wrd1,lvl2,wrd2,wrdpart
 m lvls=^torah2(bookn,versen,"lvls") ; trope
 m fslvls=^torah2(bookn,versen,"fslvls") ; syntax
 ; Compare each trope branch to each syntax branch
 s lvl1="" f  s lvl1=$o(lvls(lvl1)) q:lvl1=""  d
 . s wrd1="" f  s wrd1=$o(lvls(lvl1,wrd1)) q:wrd1=""  d
 .. s lvl2="" f  s lvl2=$o(fslvls(lvl2)) q:lvl2=""  d
 ... s wrd2="" f  s wrd2=$o(fslvls(lvl2,wrd2)) q:wrd2=""  d
 .... s wrdpart="" f  s wrdpart=$o(fslvls(lvl2,wrd2,wrdpart)) q:wrdpart=""  d
 ..... d findMismatch1(bookn,versen,lvl1,wrd1,lvl2,wrd2,wrdpart)
 q
 ;
findMismatch1(book,verse,lvl1,wrd1,lvl2,wrd2,wrdpart) ; compare two branches
 n prod,wrd10,wrd20,x,foundf
 ; wrd1 and wrd2 are the _last_ words in the branch
 s wrd10=lvls(lvl1,wrd1) ; first word in the branch
 s x=fslvls(lvl2,wrd2,wrdpart),wrd20=$p(x,U,1),syntax=$p(x,U,3)
 q:syntax=""  ; this is a leaf, <= one word long, no possible mismatch
 s prod=((wrd1-wrd2)*(wrd10-wrd2)*(wrd1-wrd20)*(wrd10-wrd20))
 s foundf=(prod<0) ; mismatch: in wrd1>wrd2>wrd10>wrd20 order, or switch them
 ; or two are equal and the other two are on different sides
 i prod=0,wrd2=wrd10,((wrd1-wrd2)*(wrd20-wrd2))<0 s foundf=2
 i prod=0,wrd20=wrd1,((wrd10-wrd1)*(wrd2-wrd1))<0 s foundf=3
 i foundf d displayMismatch(book,verse,lvl1,wrd10,wrd1,lvl2,wrd20,wrd2,wrdpart)
 q
 ;
displayMismatch(bookn,versen,lvl1,wrd10,wrd1,lvl2,wrd20,wrd2,wrdpart) ; Display trope-syntax mismatch in HTML
 ; Inputs: bookn,versen,lvl1,wrd10,wrd1,lvl2,wrd20,wrd2,wrdpart
 ; Output: HTML table with better clarity
 N posuk,wrds,wrdcnt,wordWidths,wordStartPos,i,j,k,level,endWord,partIdx
 N startWord,nodeType,part,trope,minWord,maxWord,prefix,revTropes,revSyn
 S bookName=$S(bookn=1:"B'reishis",bookn=2:"Shemos",bookn=3:"Vayikra",bookn=4:"Bamidbar",bookn=5:"Devarim",1:"Book "_bookn) ; Hebrew names
 M posuk=^torah2(bookn,versen) ; all verse info
 ; Get verse data
 S wrds=posuk,wrdcnt=posuk(0),chap=posuk("chap")
 S prefix=bookName_" "_chap_":"_versen_": "
 ; Compute word widths and positions (for alignment, but in HTML we'll use table cells)
 F i=1:1:wrdcnt D
 . S word=$tr($G(posuk(i)),NONLETTERS),wordWidths(i)=$L(word) ; remove vowels and trope.
 . S wordStartPos(i)=$S(i=1:1,1:wordStartPos(i-1)+wordWidths(i-1)+1) ; adding a space
 ; Determine mismatch range
 S minWord=$S(wrd10<wrd20:wrd10,1:wrd20),maxWord=$S(wrd1>wrd2:wrd1,1:wrd2)
 I minWord>wrd1 S minWord=wrd1
 I minWord>wrd2 S minWord=wrd2
 I maxWord<wrd10 S maxWord=wrd10
 I maxWord<wrd20 S maxWord=wrd20
 ; Output HTML structure
 d add("<div>")
 d add("<h3>"_prefix_"</h3>")
 d add("<p>"_wrds_"</p>")
 ; Mismatch summary
 S summary="Mismatch: Trope branch (level "_lvl1_", words "_wrd10_"-"_wrd1_") partially overlaps with syntax branch (level "_lvl2_", words "_wrd20_"-"_wrd2_", part "_wrdpart_"). "
 S summary=summary_"This indicates a potential discrepancy between cantillation breaks and syntactic grouping."
 d add("<div class='mismatch-summary' style='background-color: #f0f0f0; padding: 10px; margin-bottom: 10px;'>"_(summary)_"</div>")
 ; Table
 d add("<table border='1' style='border-collapse: collapse; direction: rtl;'>")
 ; Row 1: Words (bold overlapping ones)
 d add("<tr>")
 F i=maxWord:-1:minWord D
 . S style=""
 . I (i>=wrd10&(i<=wrd1))!(i>=wrd20&(i<=wrd2)) S style=" style='font-weight: bold; background-color: #ffff99;'"
 . d add("<td"_style_">"_posuk(i)_"</td>")
 d add("</tr>")
 ; Row 2: Tropes
 d add("<tr>")
 F i=maxWord:-1:minWord D
 . S revTropes(i)=$$getTaam(.posuk,i)
 . I i=wrd10 S revTropes(i)="((" _ revTropes(i)
 . I i=wrd1 S revTropes(i)=revTropes(i) _ "))"
 . F level=1:1:4 I $D(posuk("lvls",level,i)) D ; section ends at this word
 .. S startWord=posuk("lvls",level,i) ; initial word beginning the section
 .. I startWord<i,revTropes(i)="" S revTropes(i)="..."
 .. I level=lvl1,wrd10=i,wrd1=startWord S revTropes(i)=revTropes(i)_" ((...))"
 .. E  I startWord=i S revTropes(i)=revTropes(i)_" ))"
 .. E  I i=startWord S revTropes(i)=" (("
 . S style=" style='color: blue;'"
 . d add("<td"_style_">"_$G(revTropes(i))_"</td>")
 d add("</tr>")
 ; Row 3: Syntax (with parts separated into spans)
 d add("<tr>")
 F i=maxWord:-1:minWord D
 . S revSyn(i)=""
 . F partIdx=1:1 Q:'$D(posuk("fslvls",4,i,partIdx))  D
 .. S node=posuk("fslvls",4,i,partIdx)
 .. S nodeType=$P(node,"^",3),part=$P(node,"^",4)
 .. I partIdx=wrdpart S nodeType="<b>"_nodeType_"</b>" ; Highlight wrdpart
 .. S revSyn(i)=revSyn(i)_$S(revSyn(i)="":"","",1:"<br/>")_"<span class='syntax-part'>"_nodeType_"</span>"
 . I i=wrd20 S revSyn(i)="<span class='branch-start'>(("</span><br/>" _ revSyn(i)
 . I i=wrd2 S revSyn(i)=revSyn(i) _ "<br/><span class='branch-end'>))</span>"
 . F level=1:1:3 S endWord="" F  S endWord=$O(posuk("fslvls",level,endWord)) Q:endWord=""  D
 .. F partIdx=1:1 Q:'$D(posuk("fslvls",level,endWord,partIdx))  D
 ... S node=posuk("fslvls",level,endWord,partIdx)
 ... S startWord=$P(node,"^",1),nodeType=$P(node,"^",3)
 ... I startWord<=i,endWord>=i D
 .... S revSyn(i)=revSyn(i)_"<br/><span class='syntax-part'>"_nodeType_"</span>"
 . S style=" style='color: green;'"
 . d add("<td"_style_">"_$G(revSyn(i))_"</td>")
 d add("</tr>")
 d add("</table>")
 d add("<br/>")
 d add("</div>")
 Q
 ;
getTaam(posuk,i) ; for ith word
 n taam,unicode
 s taam=""
 s unicode="" f  s unicode=$o(posuk(i,"ta'am",unicode)) q:unicode=""  d
 . s taam1=chars(unicode,"name"),taam=taam_$s(taam="":"",1:" ")_taam1
 q taam
 ;
add(x)	;
	n glb1
	s glb1="^UTILITY("_$j_",""out"")"
	s (cnt,@glb1@(0))=$g(@glb1@(0))+1
	s @glb1@(cnt)=x
	q
	;</content>
</xai:function_call > 

Assistant: I created a new file with the modified code. Key changes:

- In the syntax row, for each word i, build revSyn(i) with <span class='syntax-part'> for each nodeType, separated by <br/> to stack them vertically.

- (( )) are <span class='branch-start'> and <span class='branch-end'>.

- For additional levels, append with <br/><span class='syntax-part'>.

This separates the parts into individual lines within the cell, allowing better handling.

Also, added CSS suggestions in the response. 

Now, respond with the proposal. 

To apply this, the user can replace the relevant section in their mkrqr7.int. 

Since they have per-book output, they can test on Genesis. 

Also, suggest adding CSS for .syntax-part { display: block; } to ensure vertical stacking. 

But since I used <br/>, it will stack anyway. 

For indentation, perhaps add margin-left to .syntax-part. 

But for now, this should work. 

The response should explain the change. 

If they want a sub-table, I can modify further, but this is simpler. 

A sub-table would be: for each word, <td><table><tr><td>part1</td></tr><tr><td>part2</td></tr></table></td>

But that might make columns misalign if parts differ. 

Spans with <br/> are better for vertical separation within the cell. 

Yes. 

Final response: Explain the proposed change, show how it separates parts, and suggest testing. 

Also, mention that tropes can be done similarly if needed. 

For tropes, since taam are space-separated, perhaps split into spans too, but for now, focus on syntax as requested. 

Yes. 

To implement merge, but the user wants to start with this. 

So, response. 

<xai:function_call name="create_todo_list">
<parameter name="updates">[{"id":"modify_code_if_needed","status":"completed","content":"Created mkrqr7_html_parts.int with syntax parts separated into <span> elements, stacked vertically with <br/>, and (( )) as spans for better HTML structure and CSS styling."}]