mkrqr7	; mkr 07/31/2025; kriah (קריה), trop (טעמים), and syntax - various queries
	;
	;
findMismatch ; Find mismatches between trop (lvls) and syntax (fslvls) trees in ^torah2
 n bookName,chars,glb0,glb1,NONLETTERS,sefer,sefarim
 ;
 s U="^",P="|",sp=" "
 s glb0="^torah2",glb1="^TMP("_$j_",""out"")"
 k @glb1
 ;
 m chars=^mkr4("chars")
 m sefarim=^mkr4("sefer") ; details about various books of Tanach
 s NONLETTERS="" f i=1425:1:1469,1471:1:1479 s NONLETTERS=NONLETTERS_$c(i) ; all characters that aren't aleph - tav
 ;f bookn=1:1:35 d
 f bookn=1 d  ; DEBUGGING
 . m sefer=sefarim(bookn)
 . s sefer1=$$zconvert^mkrutl(sefer,"O","UTF8")
 . S bookName=sefarim(bookn,"eng") ; Map bookn to name
 . d includeFile("header.html")
 . f versen=1:1 q:'$d(^torah2(bookn,versen))  d findMismatchVerse(bookn,versen)
 . d includeFile("footer.html")
 . d writeout^mkrqr1(bookn,glb1,"findMismatch"_bookName,"QRCode\out","html") ; output to file
 . k @glb1
 q
 ;
findMismatchVerse(bookn,versen) ; Find mismatches for a specific verse
 n lvls,fslvls,lvl1,wrd1,lvl2,wrd2,wrdpart,posuk
 ;
 M posuk=^torah2(bookn,versen) ; all verse info
 ; Get lvls (trop levels)
 m lvls=posuk("lvls")
 ;
 ; Get fslvls (syntax levels)
 m fslvls=posuk("fslvls")
 ;
 s lvl1="" f  s lvl1=$o(lvls(lvl1)) q:lvl1=""  d  ; trop
 . s wrd1="" f  s wrd1=$o(lvls(lvl1,wrd1)) q:wrd1=""  d
 .. s lvl2="" f  s lvl2=$o(fslvls(lvl2)) q:lvl2=""  d  ; syntax
 ... s wrd2="" f  s wrd2=$o(fslvls(lvl2,wrd2)) q:wrd2=""  d
 .... s wrdpart="" f  s wrdpart=$o(fslvls(lvl2,wrd2,wrdpart)) q:wrdpart=""  d
 ..... d findMismatch1(bookn,versen,lvl1,wrd1,lvl2,wrd2,wrdpart)
 q
 ;
findMismatch1(book,verse,lvl1,wrd1,lvl2,wrd2,wrdpart) ; compare two branches
 n prod,wrd10,wrd20,x,foundf
 ; wrd1 and wrd2 are the _last_ words in the branch
 s wrd10=lvls(lvl1,wrd1) ; first word in the branch
 s x=fslvls(lvl2,wrd2,wrdpart),wrd20=$p(x,U,1),syntax=$p(x,U,3)
 q:syntax=""  ; this is a leaf, <= one word long, no possible mismatch
 s prod=((wrd1-wrd2)*(wrd10-wrd2)*(wrd1-wrd20)*(wrd10-wrd20))
 s foundf=(prod<0) ; mismatch: in wrd1>wrd2>wrd10>wrd20 order, or switch them
 ; or two are equal and the other two are on different sides
 i prod=0,wrd2=wrd10,((wrd1-wrd2)*(wrd20-wrd2))<0 s foundf=2
 i prod=0,wrd20=wrd1,((wrd10-wrd1)*(wrd2-wrd1))<0 s foundf=3
 i foundf d displayMismatch(book,verse,lvl1,wrd10,wrd1,lvl2,wrd20,wrd2)
 q
 ;
displayMismatch(bookn,versen,lvl1,wrd10,wrd1,lvl2,wrd20,wrd2) ; Display trop-syntax mismatch
 ; Inputs: bookn,versen,lvl1,wrd10,wrd1,lvl2,wrd20,wrd2,wrdpart
 ; Output: 4-row monospaced text display, all RTL
 N posuk,wrds,wrdcnt,i,j,k,level,level0,endWord,partIdx
 N startWord,nodeType,part,trop,minWord,maxWord,prefix,revTrops,revSyn,mismatchCnt
 ;
 M posuk=^torah2(bookn,versen) ; all verse info
 ; Get verse data
 S wrds=posuk,wrdcnt=posuk(0),chap=posuk("chap"),verse=posuk("verse")
 ;
 ; Increment mismatch counter for this verse to ensure unique IDs
 S mismatchCnt=$G(posuk("mismatchCnt"))+1
 S posuk("mismatchCnt")=mismatchCnt
 ;
 S minWord=$S(wrd10<wrd20:wrd10,1:wrd20),maxWord=$S(wrd1>wrd2:wrd1,1:wrd2)
 I minWord>wrd1 S minWord=wrd1
 I minWord>wrd2 S minWord=wrd2
 I maxWord<wrd10 S maxWord=wrd10
 I maxWord<wrd20 S maxWord=wrd20
 ;
 ; Prepare trops and syntax for the range,
 ;  adding brackets for the sections and sub-sections
 ;
 F i=minWord:1:maxWord D
 . ; Trops - build list
 . S trop=$$getTaam(.posuk,i)
 . S revTrops(i)=trop
 ;
 F level=4:-1:1 D ; sections begin and end, enclose in ( )
 . s endWord="" f  s endWord=$o(posuk("lvls",level,endWord)) q:endWord=""  D
 .. S startWord=posuk("lvls",level,endWord) ; initial word beginning the section
 ..; these might be inside or outside our range
 .. Q:startWord>maxWord  Q:endWord<minWord  ; totally off the radar
 .. I startWord<minWord Q:((level+1)<lvl1)  d  ; add parens on first and last word of section
 ... d aTP(.revTrops,minWord,"R",1,level,startWord,endWord,chap,verse,lvl1,wrd10,wrd1,mismatchCnt)
 .. E  d aTP(.revTrops,startWord,"R",,level,startWord,endWord,chap,verse,lvl1,wrd10,wrd1,mismatchCnt)
 .. I endWord>maxWord Q:((level+1)<lvl1)  d
 ... d aTP(.revTrops,maxWord,"L",1,level,startWord,endWord,chap,verse,lvl1,wrd10,wrd1,mismatchCnt)
 .. E  d aTP(.revTrops,endWord,"L",,level,startWord,endWord,chap,verse,lvl1,wrd10,wrd1,mismatchCnt)
 ;
 ; Syntax - build list
 
 S level0=$o(posuk("fslvls",""),-1) ; deepest level reached
 F level=level0:-1:1 D ; sections begin and end, enclose in ( )
 . s endWord="" f  s endWord=$o(posuk("fslvls",level,endWord)) q:endWord=""  D
 .. Q:endWord<minWord  ; totally off the radar
 .. s endPart="" f  s endPart=$o(posuk("fslvls",level,endWord,endPart)) q:endPart=""  D
 ... S node=posuk("fslvls",level,endWord,endPart)
 ... S startWord=$p(node,U),startPart=$p(node,U,2) ; initial word,part beginning the section
 ... Q:startWord>maxWord   ; totally off the radar
 ... S syntax=$P(node,U,3),txt=$P(node,U,4),leafSyntax=$p(node,U,5)
 ... I syntax="" D  Q  ; don't add parens just for a leaf alone
 ....; for leaf, startWord=endWord,startPart=endPart
 .... i startWord'=endWord W !,"error startWord "_startWord_", endword "_endWord q
 .... i startPart'=endPart W !,"error startPart "_startPart_", endword "_endPart q
 .... d aSP(.revSyn,startWord,startPart,0,,leafSyntax,level,startWord,endWord,chap,verse,startPart,startPart,lvl2,wrd20,wrd2,mismatchCnt)
 ... Q:((level+1)<lvl1)  ; don't need to look that far out
 ... ; add parens on first and last word of section, and syntax
 ... I startWord<minWord d  ; add ...
 .... d aSP(.revSyn,minWord,,"R",1,,level,startWord,endWord,chap,verse,startPart,endPart,lvl2,wrd20,wrd2,mismatchCnt)
 ... E  d aSP(.revSyn,startWord,startPart,"R",,,level,startWord,endWord,chap,verse,startPart,endPart,lvl2,wrd20,wrd2,mismatchCnt)
 ... I endWord>maxWord d
 .... d aSP(.revSyn,maxWord,,"L",1,syntax,level,startWord,endWord,chap,verse,startPart,endPart,lvl2,wrd20,wrd2,mismatchCnt)
 ... E  d aSP(.revSyn,endWord,endPart,"L",,syntax,level,startWord,endWord,chap,verse,startPart,endPart,lvl2,wrd20,wrd2,mismatchCnt)
 ;
 d add("<div class='verse-container'>")
 ;
 s txt=wrds
 i wrd10<wrd20 d
 . s x1=$p(txt,sp,1,wrd10-1),x2=$p(txt,sp,wrd10,wrd20-1),x3=$p(txt,sp,wrd20,wrd1),x4=$p(txt,sp,wrd1+1,wrd2),x5=$p(txt,sp,wrd2+1,999)
 . s prefix=$g(x1)_" <span class='verse-trop'> "_$g(x2)_"</span><span class='verse-trop-syntax'> "_$g(x3)_"</span><span class='verse-syntax'> "_$g(x4)_"</span> "_$g(x5)
 e  d  ; wrd20<wrd10
 . s x1=$p(txt,sp,1,wrd20-1),x2=$p(txt,sp,wrd20,wrd10-1),x3=$p(txt,sp,wrd10,wrd2),x4=$p(txt,sp,wrd2+1,wrd1),x5=$p(txt,sp,wrd1+1,999)
 . s prefix=$g(x1)_" <span class='verse-syntax'> "_$g(x2)_"</span><span class='verse-trop-syntax'> "_$g(x3)_"</span><span class='verse-trop'> "_$g(x4)_"</span> "_$g(x5)
 d add("B'reishis "_chap_":"_verse_" "_$$zconvert^mkrutl(prefix,"O","UTF8"))
 ; Row 1a: mismatch info
 s txt="<div class='mismatch_data'>Mismatch: trop branch words "_wrd10_" - "_wrd1_", "
 s txt=txt_"<span class='verse-trop' data-words='"_wrd10_"-"_wrd1_"'>"_$p(wrds,sp,wrd10)_" - "_$p(wrds,sp,wrd1)_"</span>"
 s txt=txt_". Syntax branch words "_wrd20_" - "_wrd2_", "
 s txt=txt_"<span class='verse-syntax' data-words='"_wrd20_"-"_wrd2_"'>"_$p(wrds,sp,wrd20)_" - "_$p(wrds,sp,wrd2)_"</span>.</div>"
 d add($$zconvert^mkrutl(txt,"O","UTF8"))
 ;
 d add("<div class='table-container'>")
 ; Determine how many words per segment dynamically based on total words and syntax complexity
 ; Aim for segments of around 10 words, but reduce if there are many syntax elements per word
 S totalWords=maxWord-minWord+1
 ; Calculate complexity based on number of syntax elements
 S complexity=0
 F i=minWord:1:maxWord D
 . S j="" F  S j=$o(revSyn(i,j)) q:j=""  D
 .. F k="L",0,"R" I $D(revSyn(i,j,k)) D
 ... S cnt=$G(revSyn(i,j,k,0),0)
 ... S complexity=complexity+cnt
 ; Adjust segment size based on total words and complexity
 S avgComplexityPerWord=$S(totalWords>0:complexity/totalWords,1:1)
 S segmentSize=$S(totalWords>30:15,totalWords>15:10,1:8)
 I avgComplexityPerWord>2 S segmentSize=$S(segmentSize>10:segmentSize-2,1:segmentSize-1)
 I avgComplexityPerWord>4 S segmentSize=$S(segmentSize>8:segmentSize-2,1:segmentSize-1)
 S segmentSize=$S(segmentSize<5:5,1:segmentSize) ; Ensure minimum segment size
 S currentWord=maxWord
 S segmentCount=0
 F  Q:currentWord<minWord  D
 . S segmentStart=currentWord
 . S segmentEnd=$S(currentWord-segmentSize+1<minWord:minWord,1:currentWord-segmentSize+1)
 . S segmentCount=segmentCount+1
 . d add("<table class='segment-table' data-segment='"_segmentCount_"'>")
 . 
 . ; Row: Words
 . d add("<tr>")
 . s rowWords=""
 . F i=segmentStart:-1:segmentEnd D
 .. S word=posuk(i) ; number of characters
 .. S rowWords = rowWords _ "<td data-word='"_i_"'>"_word_"</td>"
 . d add($$zconvert^mkrutl(rowWords,"O","UTF8"))
 . d add("</tr>")
 . 
 . ; Row: trops
 . d add("<tr>")
 . s rowTrops="" ; build string
 . F i=segmentEnd:1:segmentStart D
 .. S tropL=$g(revTrops(i,"L")),trop=$g(revTrops(i)),tropR=$g(revTrops(i,"R"))
 .. S tropClass="verse-trop"_$S(i=wrd1:" mismatch-pair",1:"")
 .. S rowTrops = rowTrops _ "<td>"_tropL_"<span class='"_tropClass_"'>"_$zstrip(trop,"<W")_"</span>"_tropR_"</td>"
 . d add(rowTrops)
 . d add("</tr>")
 . 
 . ; Row: Syntax
 . d add("<tr>")
 . F i=segmentStart:-1:segmentEnd D  ; leaf syntax
 .. d add("<td>")
 .. S j="" F  S j=$o(revSyn(i,j),-1) q:j=""  d  ; word-part
 ... S partTxt=""
 ... F k="L",0,"R" i $d(revSyn(i,j,k)) d  ; leaf or syntax branch ends
 .... S class=$s(k=0:"syntax-part",k="L":"branch-end",k="R":"branch-start",1:"")
 .... I k="L" F cnt=$g(revSyn(i,j,k,0)):-1:1 d  ; maybe several on one part, esp. ('s
 ..... S part=revSyn(i,j,k,cnt)
 ..... S partTxt=partTxt_part
 .... E  F cnt=1:1:$g(revSyn(i,j,k,0)) d  ; maybe several on one part, esp. ('s
 ..... S part=revSyn(i,j,k,cnt)
 ..... S partTxt=partTxt_part
 ... d add(partTxt)
 .. d add("</td>")
 . d add("</tr>")
 . d add("</table>")
 . S currentWord=segmentEnd-1
 d add("</div>")
 d add("<br/>")
 d add("<br/>")
 q
 ;
getTaam(posuk,i) ; for ith word
 n taam,unicode
 s taam=""
 s unicode="" f  s unicode=$o(posuk(i,"ta'am",unicode)) q:unicode=""  d
 . q:unicode="mult"  ; multiple ta'amim on one word flag
 . q:unicode="missing"
 . s taam1=chars(unicode,"name"),taam=taam_$s(taam="":"",1:" ")_taam1
 q taam
 ;
aTP(revTrops,wordIdx,direction,dots,level,startWord,endWord,chap,verse,mismatchLevel,mismatchStart,mismatchEnd,mismatchCnt)	; add left/right paren. revTrops array in/out by reference
 n dottxt,txt1,id,class
 s dottxt="" i $g(dots) s dottxt="..."
 s id="trop-"_chap_"-"_verse_"-"_mismatchCnt_"-"_level_"-"_startWord_"-"_endWord_"-"_direction
 s class = $s(direction="L":"branch-end",direction="R":"branch-start",1:"")_" trop-level-"_level
 i (level=mismatchLevel) & (startWord=mismatchStart) & (endWord=mismatchEnd) s class = class_" mismatch-pair"
 i direction="L" s revTrops(wordIdx,"L") = "<span id='"_id_"' class='"_class_"'>("_dottxt_"</span>"_$g(revTrops(wordIdx,"L"))
 i direction="R" s revTrops(wordIdx,"R") = $g(revTrops(wordIdx,"R"))_"<span id='"_id_"' class='"_class_"'>"_dottxt_")</span>"
 q
 ;
aSP(revTrops,wordIdx,partIdx,direction,dots,syntax,level,startWord,endWord,chap,verse,startPart,endPart,mismatchLevel,mismatchStart,mismatchEnd,mismatchCnt)	; add left/right paren., and syntax just next to left paren (on last word in section)
 ; leaves and syntax are (somewhat) independent: leaves never need ( ), syntax always does.
 n cnt,dottxt,txt1,id,class
 s partIdx=$g(partIdx)
 i partIdx="" s partIdx=$s(direction="L":1000,direction="R":0,1:"") ; use 0 or 1000 if not specified to make it the last one
 s syntax=$g(syntax)
 s dottxt="" i $g(dots) s dottxt="..."
 s id="syntax-"_chap_"-"_verse_"-"_mismatchCnt_"-"_level_"-"_startWord_"-"_endWord_"-"_startPart_"-"_endPart_"-"_direction
 s class = $s(direction="L":"branch-end syntax-level-"_level,direction="R":"branch-start syntax-level-"_level,1:"syntax-part")
 i (direction="L"!(direction="R")) & (level=mismatchLevel) & (startWord=mismatchStart) & (endWord=mismatchEnd) s class = class_" mismatch-pair"
 i direction=0 s (cnt,revSyn(wordIdx,partIdx,0,0))=$g(revSyn(wordIdx,partIdx,0,0))+1,revSyn(wordIdx,partIdx,0,cnt)="<span class='syntax-part'>"_syntax_"</span>"
 i direction="L" s (cnt,revSyn(wordIdx,partIdx,"L",0)) = $g(revSyn(wordIdx,partIdx,"L",0))+1,revSyn(wordIdx,partIdx,"L",cnt)="<span id='"_id_"' class='"_class_"'>("_dottxt_syntax_"</span>"
 i direction="R" s (cnt,revSyn(wordIdx,partIdx,"R",0))=$g(revSyn(wordIdx,partIdx,"R",0))+1,revSyn(wordIdx,partIdx,"R",cnt) = "<span id='"_id_"' class='"_class_"'>"_dottxt_")</span>"
 q
 ;
add(x)	;
	n cnt,glb1
	s glb1="^TMP("_$j_",""out"")"
	s (cnt,@glb1@(0))=$g(@glb1@(0))+1
	s @glb1@(cnt)=x
	q
	;
includeFile(filename) ;
 n file,i,inary,subpath
 s subpath="QR\QRCode\out\includes\"
 d readin1 ; loads inary array
 f i=1:1 q:'$d(inary(i))  d
 . d add(inary(i))
 q
readin1 ; Read single file
 k inary
 d getfile^mkrutl(filename,.inary,subpath)
 q
