mkrqr8	; mkr 08/01/2025; kriah (קריה), trop (טעמים), and syntax - comprehensive verse output with selectable mismatches
	;
	;
generateAllVerses ; Generate output for all verses in ^torah2 with mismatch highlighting
 n bookName,chars,glb0,glb1,sefer,sefarim
 ;
 s U="^",P="|",sp=" "
 s glb0="^torah2",glb1="^TMP("_$j_",""out"")"
 k @glb1
 ;
 m chars=^mkr4("chars")
 m sefarim=^mkr4("sefer") ; details about various books of Tanach
 f bookn=1 d  ; DEBUGGING - only first book
 . m sefer=sefarim(bookn)
 . s sefer1=$$zconvert^mkrutl(sefer,"O","UTF8")
 . S bookName=sefarim(bookn,"eng") ; Map bookn to name
 . d includeFile("header.html")
 . f versen=1:1 q:'$d(^torah2(bookn,versen))  d generateVerseOutput(bookn,versen)
 . d includeFile("footer.html")
 . d writeout^mkrqr1(bookn,glb1,"allVerses"_bookName,"QRCode\out","html") ; output to file
 . d writeout^mkrqr1(bookn,glb1,"preview_allVerses"_bookName,"QRCode\out","html",500) ; output preview to file, 500 rows
 . k @glb1
 q
 ;
generateVerseOutput(bookn,versen) ; Generate output for a specific verse, including all words and mismatches if any
 n lvls,fslvls,lvl1,wrd1,lvl2,wrd2,wrdpart,posuk
 n mismatches,mismatchCnt,mismatchIdx
 ;
 M posuk=^torah2(bookn,versen) ; all verse info
 ; Get lvls (trop levels)
 m lvls=posuk("lvls")
 ;
 ; Get fslvls (syntax levels)
 m fslvls=posuk("fslvls")
 ;
 ; Initialize mismatch counter and storage
 S mismatchCnt=0
 K mismatches

 ; Collect mismatches for this verse
 s lvl1="" f  s lvl1=$o(lvls(lvl1)) q:lvl1=""  d  ; trop
 . s wrd1="" f  s wrd1=$o(lvls(lvl1,wrd1)) q:wrd1=""  d
 .. s lvl2="" f  s lvl2=$o(fslvls(lvl2)) q:lvl2=""  d  ; syntax
 ... s wrd2="" f  s wrd2=$o(fslvls(lvl2,wrd2)) q:wrd2=""  d
 .... s wrdpart="" f  s wrdpart=$o(fslvls(lvl2,wrd2,wrdpart)) q:wrdpart=""  d
 ..... d checkMismatch(bookn,versen,lvl1,wrd1,lvl2,wrd2,wrdpart,.mismatches,.mismatchCnt)

 ; Generate output for the verse
 d displayVerse(bookn,versen,.mismatches,mismatchCnt)
 q
 ;
checkMismatch(book,verse,lvl1,wrd1,lvl2,wrd2,wrdpart,mismatches,mismatchCnt) ; compare two branches and store mismatches
 n prod,wrd10,wrd20,x,foundf
 ; wrd1 and wrd2 are the _last_ words in the branch
 s wrd10=lvls(lvl1,wrd1) ; first word in the branch
 s x=fslvls(lvl2,wrd2,wrdpart),wrd20=$p(x,U,1),syntax=$p(x,U,3)
 q:syntax=""  ; this is a leaf, <= one word long, no possible mismatch
 s prod=((wrd1-wrd2)*(wrd10-wrd2)*(wrd1-wrd20)*(wrd10-wrd20))
 s foundf=(prod<0) ; mismatch: in wrd1>wrd2>wrd10>wrd20 order, or switch them
 ; or two are equal and the other two are on different sides
 i prod=0,wrd2=wrd10,((wrd1-wrd2)*(wrd20-wrd2))<0 s foundf=2
 i prod=0,wrd20=wrd1,((wrd10-wrd1)*(wrd2-wrd1))<0 s foundf=3
 i foundf d
 . S mismatchCnt=mismatchCnt+1
 . S mismatches(mismatchCnt)=lvl1_"^"_wrd10_"^"_wrd1_"^"_lvl2_"^"_wrd20_"^"_wrd2
 q
 ;
displayVerse(bookn,versen,mismatches,mismatchCnt) ; Display verse with all words and mismatches
 ; Inputs: bookn,versen
 ; Output: 3-row table display, all RTL
 N posuk,wrds,wrdcnt,i,j,k,level,level0,endWord,partIdx
 N startWord,nodeType,part,trop,minWord,maxWord,prefix,revTrops,revSyn,mismatchIdx
 ;
 M posuk=^torah2(bookn,versen) ; all verse info
 ; Get verse data
 S wrds=posuk,wrdcnt=posuk(0),chap=posuk("chap"),verse=posuk("verse")
 ;
 ; Set minWord and maxWord to cover the entire verse
 S minWord=1,maxWord=wrdcnt
 ;
 ; Prepare trops and syntax for the range
 F i=minWord:1:maxWord D
 . ; Trops - build list
 . S trop=$$getTaam(.posuk,i)
 . S revTrops(i)=trop
 ;
 ; Add trop brackets
 F level=4:-1:1 D
 . s endWord="" f  s endWord=$o(posuk("lvls",level,endWord)) q:endWord=""  D
 .. S startWord=posuk("lvls",level,endWord)
 .. Q:startWord>maxWord  Q:endWord<minWord
 .. I startWord<minWord d aTP(.revTrops,minWord,"R",1,level,startWord,endWord,chap,verse,0,0,0,0)
 .. E  d aTP(.revTrops,startWord,"R",,level,startWord,endWord,chap,verse,0,0,0,0)
 .. I endWord>maxWord d aTP(.revTrops,maxWord,"L",1,level,startWord,endWord,chap,verse,0,0,0,0)
 .. E  d aTP(.revTrops,endWord,"L",,level,startWord,endWord,chap,verse,0,0,0,0)
 ;
 ; Syntax - build list
 S level0=$o(posuk("fslvls",""),-1)
 F level=level0:-1:1 D
 . s endWord="" f  s endWord=$o(posuk("fslvls",level,endWord)) q:endWord=""  D
 .. Q:endWord<minWord
 .. s endPart="" f  s endPart=$o(posuk("fslvls",level,endWord,endPart)) q:endPart=""  D
 ... S node=posuk("fslvls",level,endWord,endPart)
 ... S startWord=$p(node,U),startPart=$p(node,U,2)
 ... Q:startWord>maxWord
 ... S syntax=$P(node,U,3),leafSyntax=$p(node,U,5)
 ... I syntax="" D  Q
 .... d aSP(.revSyn,startWord,startPart,0,,leafSyntax,level,startWord,endWord,chap,verse,startPart,startPart,0,0,0,0)
 ... I startWord<minWord d aSP(.revSyn,minWord,,"R",1,,level,startWord,endWord,chap,verse,startPart,endPart,0,0,0,0)
 ... E  d aSP(.revSyn,startWord,startPart,"R",,,level,startWord,endWord,chap,verse,startPart,endPart,0,0,0,0)
 ... I endWord>maxWord d aSP(.revSyn,maxWord,,"L",1,syntax,level,startWord,endWord,chap,verse,startPart,endPart,0,0,0,0)
 ... E  d aSP(.revSyn,endWord,endPart,"L",,syntax,level,startWord,endWord,chap,verse,startPart,endPart,0,0,0,0)
 ;
 d add("<div class='verse-container' data-chap='"_chap_"' data-verse='"_verse_"'>")
 s txt="B'reishis "_chap_":"_verse_" "_$$zconvert^mkrutl(wrds,"O","UTF8")
 d add(txt)
 ; Mismatch selection with radio buttons if any
 i mismatchCnt>0 d
 . i mismatchCnt=1 d
 .. s mismatchData=mismatches(1)
 .. s lvl1=$p(mismatchData,"^",1),wrd10=$p(mismatchData,"^",2),wrd1=$p(mismatchData,"^",3)
 .. s lvl2=$p(mismatchData,"^",4),wrd20=$p(mismatchData,"^",5),wrd2=$p(mismatchData,"^",6)
 .. s txt="<div class='mismatch-selector'>"
 .. s txt=txt_"<div class='mismatch-data mismatch-1'>Mismatch: Trop branch (level "_lvl1_") words "_wrd10_" - "_wrd1_", "
 .. s txt=txt_"<span class='verse-trop' data-words='"_wrd10_"-"_wrd1_"'>"_$p(wrds,sp,wrd10)_" - "_$p(wrds,sp,wrd1)_"</span>"
 .. s txt=txt_". Syntax branch (level "_lvl2_") words "_wrd20_" - "_wrd2_", "
 .. s txt=txt_"<span class='verse-syntax' data-words='"_wrd20_"-"_wrd2_"'>"_$p(wrds,sp,wrd20)_" - "_$p(wrds,sp,wrd2)_"</span>.</div>"
 .. s txt=txt_"</div>"
 .. d add($$zconvert^mkrutl(txt,"O","UTF8"))
 . e  d
 .. s txt="<div class='mismatch-selector'>Select Mismatch:<br>"
 .. f mismatchIdx=1:1:mismatchCnt d
 ... s mismatchData=mismatches(mismatchIdx)
 ... s lvl1=$p(mismatchData,"^",1),wrd10=$p(mismatchData,"^",2),wrd1=$p(mismatchData,"^",3)
 ... s lvl2=$p(mismatchData,"^",4),wrd20=$p(mismatchData,"^",5),wrd2=$p(mismatchData,"^",6)
 ... s checked=$s(mismatchIdx=1:" checked",1:"")
 ... s txt=txt_"<div class='mismatch-data mismatch-"_mismatchIdx_"'>"
 ... s txt=txt_"<span class='mismatch-label'>Mismatch "_mismatchIdx_": Trop branch (level "_lvl1_") words "_wrd10_" - "_wrd1_", "
 ... s txt=txt_"<span class='verse-trop' data-words='"_wrd10_"-"_wrd1_"'>"_$p(wrds,sp,wrd10)_" - "_$p(wrds,sp,wrd1)_"</span>"
 ... s txt=txt_". Syntax branch (level "_lvl2_") words "_wrd20_" - "_wrd2_", "
 ... s txt=txt_"<span class='verse-syntax' data-words='"_wrd20_"-"_wrd2_"'>"_$p(wrds,sp,wrd20)_" - "_$p(wrds,sp,wrd2)_"</span>.</span>"
 ... s txt=txt_"<input type='radio' name='mismatch-select-"_chap_"-"_verse_"' id='mismatch-"_mismatchIdx_"-"_chap_"-"_verse_"' value='"_mismatchIdx_"' data-trop='"_wrd10_"-"_wrd1_"' data-syntax='"_wrd20_"-"_wrd2_"' "_checked_" style='margin-left: 10px;'>"
 ... s txt=txt_"</div>"
 .. s txt=txt_"</div>"
 .. d add($$zconvert^mkrutl(txt,"O","UTF8"))
 ;
 d add("<div class='table-container'>")
 ; Segment the verse into manageable tables
 S totalWords=maxWord-minWord+1
 S segmentSize=$S(totalWords>30:15,totalWords>15:10,1:8)
 S currentWord=minWord
 S segmentCount=0
 F  Q:currentWord>maxWord  D
 . S segmentEnd=currentWord
 . S segmentStart=$S(currentWord+segmentSize-1>maxWord:maxWord,1:currentWord+segmentSize-1)
 . S segmentCount=segmentCount+1
 . d add("<table class='segment-table' data-segment='"_segmentCount_"'>")
 . 
 . ; Row 1: Words
 . d add("<tr class='word-row'>")
 . s rowWords=""
 . F i=segmentStart:-1:segmentEnd D
 .. S word=posuk(i)
 .. S class=""
 .. i mismatchCnt>0 d
 ... f mismatchIdx=1:1:mismatchCnt d
 .... s mismatchData=mismatches(mismatchIdx)
 .... s wrd10=$p(mismatchData,"^",2),wrd1=$p(mismatchData,"^",3)
 .... s wrd20=$p(mismatchData,"^",5),wrd2=$p(mismatchData,"^",6)
 .... i i>=wrd10,i<=wrd1 s class=$s(class="": "", 1: class_",")_"trop-mismatch-"_mismatchIdx
 .... i i>=wrd20,i<=wrd2 s class=$s(class="": "", 1: class_",")_"syntax-mismatch-"_mismatchIdx
 .. S rowWords = rowWords _ "<td data-word='"_i_"' class='"_class_"'>"_word_"</td>"
 . d add($$zconvert^mkrutl(rowWords,"O","UTF8"))
 . d add("</tr>")
 . 
 . ; Row 2: Trops
 . d add("<tr class='trop-row'>")
 . s rowTrops=""
 . F i=segmentStart:-1:segmentEnd D
 .. S tropL=$g(revTrops(i,"L")),trop=$g(revTrops(i)),tropR=$g(revTrops(i,"R"))
 .. S rowTrops = rowTrops _ "<td>"_$s(tropL'="":tropL,1:trop)_tropR_"</td>"
 . d add(rowTrops)
 . d add("</tr>")
 . 
 . ; Row 3: Syntax
 . d add("<tr class='syntax-row'>")
 . F i=segmentStart:-1:segmentEnd D
 .. d add("<td>")
 .. S j="" F  S j=$o(revSyn(i,j),-1) q:j=""  d
 ... S partTxt=""
 ... F k="L",0,"R" i $d(revSyn(i,j,k)) d
 .... I k="L" F cnt=$g(revSyn(i,j,k,0)):-1:1 d
 ..... S part=revSyn(i,j,k,cnt)
 ..... S partTxt=partTxt_part
 .... E  F cnt=1:1:$g(revSyn(i,j,k,0)) d
 ..... S part=revSyn(i,j,k,cnt)
 ..... S partTxt=partTxt_part
 ... d add(partTxt)
 .. d add("</td>")
 . d add("</tr>")
 . d add("</table>")
 . S currentWord=segmentStart+1
 d add("</div>") ; end table-container
 d add("</div>") ; end verse-container
 d add("<br />")
 q
 ;
getTaam(posuk,i) ; for ith word
 n taam,unicode
 s taam=""
 s unicode="" f  s unicode=$o(posuk(i,"ta'am",unicode)) q:unicode=""  d
 . q:unicode="mult"  ; multiple ta'amim on one word flag
 . q:unicode="missing"
 . s taam1=chars(unicode,"name"),taam=taam_$s(taam="":"",1:" ")_taam1
 q taam
 ;
aTP(revTrops,wordIdx,direction,dots,level,startWord,endWord,chap,verse,mismatchLevel,mismatchStart,mismatchEnd,mismatchCnt)
 ; Add left/right paren for trop — paren + mafsik text in ONE span (no inner span)
 n dottxt,id,class,txt
 s dottxt="" i $g(dots) s dottxt="..."
 s id="trop-"_chap_"-"_verse_"-"_mismatchCnt_"-"_level_"-"_startWord_"-"_endWord_"-"_direction
 s class=$s(direction="L":"branch-end",direction="R":"branch-start",1:"")_" trop-level-"_level
 i (level=mismatchLevel) & (startWord=mismatchStart) & (endWord=mismatchEnd) s class=class_" mismatch-pair"
 ; Left: paren + mafsik text inside the branch-end span
 i direction="L" d
 . s txt="("_dottxt_$g(revTrops(wordIdx))  ; mafsik text INSIDE
 . s revTrops(wordIdx,"L")="<span id='"_id_"' class='"_class_"'>"_txt_"</span>"
 ; Right: closing paren in its own span
 i direction="R" d
 . s txt=dottxt_")"
 . s revTrops(wordIdx,"R")=$g(revTrops(wordIdx,"R"))_"<span id='"_id_"' class='"_class_"'>"_txt_"</span>"
 q
 ;
 ;
aSP(revTrops,wordIdx,partIdx,direction,dots,syntax,level,startWord,endWord,chap,verse,startPart,endPart,mismatchLevel,mismatchStart,mismatchEnd,mismatchCnt)	; add left/right paren., and syntax just next to left paren (on last word in section)
 ; leaves and syntax are (somewhat) independent: leaves never need ( ), syntax always does.
 n cnt,dottxt,id,class
 s partIdx=$g(partIdx)
 i partIdx="" s partIdx=$s(direction="L":1000,direction="R":0,1:"") ; use 0 or 1000 if not specified to make it the last one
 s syntax=$g(syntax)
 s dottxt="" i $g(dots) s dottxt="..."
 s id="syntax-"_chap_"-"_verse_"-"_mismatchCnt_"-"_level_"-"_startWord_"-"_endWord_"-"_startPart_"-"_endPart_"-"_direction
 s class = $s(direction="L":"branch-end syntax-level-"_level,direction="R":"branch-start syntax-level-"_level,1:"syntax-part")
 i (direction="L"!(direction="R")) & (level=mismatchLevel) & (startWord=mismatchStart) & (endWord=mismatchEnd) s class = class_" mismatch-pair"
 i (level=mismatchLevel) & (startWord=mismatchStart) & (endWord=mismatchEnd) s outerClass=outerClass_" mismatch-pair"
 i direction=0 d
 . s (cnt,revSyn(wordIdx,partIdx,0,0))=$g(revSyn(wordIdx,partIdx,0,0))+1
 . s revSyn(wordIdx,partIdx,0,cnt)="<span class='syntax-part'>"_syntax_"</span>"
 i direction="L" d
 . s (cnt,revSyn(wordIdx,partIdx,"L",0)) = $g(revSyn(wordIdx,partIdx,"L",0))+1
 . s revSyn(wordIdx,partIdx,"L",cnt)="<span id='"_id_"' class='"_class_"'>("_dottxt_syntax_"</span>"
 i direction="R" d
 . s (cnt,revSyn(wordIdx,partIdx,"R",0))=$g(revSyn(wordIdx,partIdx,"R",0))+1
 . s revSyn(wordIdx,partIdx,"R",cnt) = "<span id='"_id_"' class='"_class_"'>"_dottxt_")</span>"
 q
 ;
add(x)	;
	n cnt,glb1
	s glb1="^TMP("_$j_",""out"")"
	s (cnt,@glb1@(0))=$g(@glb1@(0))+1
	s @glb1@(cnt)=x
	q
	;
includeFile(filename) ;
 n file,i,inary,subpath
 s subpath="QR\QRCode\out\includes\"
 d readin1 ; loads inary array
 f i=1:1 q:'$d(inary(i))  d
 . d add(inary(i))
 q
readin1 ; Read single file
 k inary
 d getfile^mkrutl(filename,.inary,subpath)
 q
