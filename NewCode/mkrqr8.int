mkrqr8	; mkr 08/01/2025; kriah (קריה), trop (טעמים), and syntax - comprehensive verse output with selectable mismatches
	;
	;
generateAllVerses ; Generate output for all verses in ^torah2 with optional mismatch highlighting
 n bookName,chars,glb0,glb1,NONLETTERS,sefer,sefarim
 ;
 s U="^",P="|",sp=" "
 s glb0="^torah2",glb1="^TMP("_$j_",""out"")"
 k @glb1
 ;
 m chars=^mkr4("chars")
 m sefarim=^mkr4("sefer") ; details about various books of Tanach
 s NONLETTERS="" f i=1425:1:1469,1471:1:1479 s NONLETTERS=NONLETTERS_$c(i) ; all characters that aren't aleph - tav
 ;f bookn=1:1:35 d
 f bookn=1 d  ; DEBUGGING
 . m sefer=sefarim(bookn)
 . s sefer1=$$zconvert^mkrutl(sefer,"O","UTF8")
 . S bookName=sefarim(bookn,"eng") ; Map bookn to name
 . d includeFile("header.html")
 . f versen=1:1 q:'$d(^torah2(bookn,versen))  d generateVerseOutput(bookn,versen)
 . d includeFile("footer.html")
 . d writeout^mkrqr1(bookn,glb1,"allVerses"_bookName,"QRCode\out","html") ; output to file
 . k @glb1
 q
 ;
generateVerseOutput(bookn,versen) ; Generate output for a specific verse, including all words and mismatches if any
 n lvls,fslvls,lvl1,wrd1,lvl2,wrd2,wrdpart,posuk
 n mismatches,mismatchCnt,mismatchIdx
 ;
 M posuk=^torah2(bookn,versen) ; all verse info
 ; Get lvls (trop levels)
 m lvls=posuk("lvls")
 ;
 ; Get fslvls (syntax levels)
 m fslvls=posuk("fslvls")
 ;
 ; Initialize mismatch counter and storage
 S mismatchCnt=0
 K mismatches

 ; Collect mismatches for this verse
 s lvl1="" f  s lvl1=$o(lvls(lvl1)) q:lvl1=""  d  ; trop
 . s wrd1="" f  s wrd1=$o(lvls(lvl1,wrd1)) q:wrd1=""  d
 .. s lvl2="" f  s lvl2=$o(fslvls(lvl2)) q:lvl2=""  d  ; syntax
 ... s wrd2="" f  s wrd2=$o(fslvls(lvl2,wrd2)) q:wrd2=""  d
 .... s wrdpart="" f  s wrdpart=$o(fslvls(lvl2,wrd2,wrdpart)) q:wrdpart=""  d
 ..... d checkMismatch(bookn,versen,lvl1,wrd1,lvl2,wrd2,wrdpart,.mismatches,.mismatchCnt)

 ; Generate output for the verse
 d displayVerse(bookn,versen,.mismatches,mismatchCnt)
 q
 ;
checkMismatch(book,verse,lvl1,wrd1,lvl2,wrd2,wrdpart,mismatches,mismatchCnt) ; compare two branches and store mismatches
 n prod,wrd10,wrd20,x,foundf
 ; wrd1 and wrd2 are the _last_ words in the branch
 s wrd10=lvls(lvl1,wrd1) ; first word in the branch
 s x=fslvls(lvl2,wrd2,wrdpart),wrd20=$p(x,U,1),syntax=$p(x,U,3)
 q:syntax=""  ; this is a leaf, <= one word long, no possible mismatch
 s prod=((wrd1-wrd2)*(wrd10-wrd2)*(wrd1-wrd20)*(wrd10-wrd20))
 s foundf=(prod<0) ; mismatch: in wrd1>wrd2>wrd10>wrd20 order, or switch them
 ; or two are equal and the other two are on different sides
 i prod=0,wrd2=wrd10,((wrd1-wrd2)*(wrd20-wrd2))<0 s foundf=2
 i prod=0,wrd20=wrd1,((wrd10-wrd1)*(wrd2-wrd1))<0 s foundf=3
 i foundf d
 . S mismatchCnt=mismatchCnt+1
 . S mismatches(mismatchCnt)=lvl1_"^"_wrd10_"^"_wrd1_"^"_lvl2_"^"_wrd20_"^"_wrd2
 q
 ;
displayVerse(bookn,versen,mismatches,mismatchCnt) ; Display verse with all words and optional mismatches
 ; Inputs: bookn,versen
 ; Output: 4-row monospaced text display, all RTL
 N posuk,wrds,wrdcnt,i,j,k,level,level0,endWord,partIdx
 N startWord,nodeType,part,trop,minWord,maxWord,prefix,revTrops,revSyn,mismatchIdx
 N lvl1,wrd10,wrd1,lvl2,wrd20,wrd2
 ;
 M posuk=^torah2(bookn,versen) ; all verse info
 ; Get verse data
 S wrds=posuk,wrdcnt=posuk(0),chap=posuk("chap"),verse=posuk("verse")
 ;
 ; Set minWord and maxWord to cover the entire verse
 S minWord=1,maxWord=wrdcnt
 ;
 ; Prepare trops and syntax for the range,
 ;  adding brackets for the sections and sub-sections
 ;
 F i=minWord:1:maxWord D
 . ; Trops - build list
 . S trop=$$getTaam(.posuk,i)
 . S revTrops(i)=trop
 ;
 ; Initialize mismatch variables to avoid UNDEF errors when no mismatches exist
 S lvl1="",wrd10=0,wrd1=0,lvl2="",wrd20=0,wrd2=0
 ;
 F level=4:-1:1 D ; sections begin and end, enclose in ( )
 . s endWord="" f  s endWord=$o(posuk("lvls",level,endWord)) q:endWord=""  D
 .. S startWord=posuk("lvls",level,endWord) ; initial word beginning the section
 ..; these might be inside or outside our range
 .. Q:startWord>maxWord  Q:endWord<minWord  ; totally off the radar
 .. I startWord<minWord Q:((level+1)<lvl1)  d  ; add parens on first and last word of section
 ... d aTP(.revTrops,minWord,"R",1,level,startWord,endWord,chap,verse,lvl1,wrd10,wrd1,mismatchCnt)
 .. E  d aTP(.revTrops,startWord,"R",,level,startWord,endWord,chap,verse,lvl1,wrd10,wrd1,mismatchCnt)
 .. I endWord>maxWord Q:((level+1)<lvl1)  d
 ... d aTP(.revTrops,maxWord,"L",1,level,startWord,endWord,chap,verse,lvl1,wrd10,wrd1,mismatchCnt)
 .. E  d aTP(.revTrops,endWord,"L",,level,startWord,endWord,chap,verse,lvl1,wrd10,wrd1,mismatchCnt)
 ;
 ; Syntax - build list
 S level0=$o(posuk("fslvls",""),-1) ; deepest level reached
 F level=level0:-1:1 D ; sections begin and end, enclose in ( )
 . s endWord="" f  s endWord=$o(posuk("fslvls",level,endWord)) q:endWord=""  D
 .. Q:endWord<minWord  ; totally off the radar
 .. s endPart="" f  s endPart=$o(posuk("fslvls",level,endWord,endPart)) q:endPart=""  D
 ... S node=posuk("fslvls",level,endWord,endPart)
 ... S startWord=$p(node,U),startPart=$p(node,U,2) ; initial word,part beginning the section
 ... Q:startWord>maxWord   ; totally off the radar
 ... S syntax=$P(node,U,3),txt=$P(node,U,4),leafSyntax=$p(node,U,5)
 ... I syntax="" D  Q  ; don't add parens just for a leaf alone
 ....; for leaf, startWord=endWord,startPart=endPart
 .... i startWord'=endWord W !,"error startWord "_startWord_", endword "_endWord q
 .... i startPart'=endPart W !,"error startPart "_startPart_", endword "_endPart q
 .... d aSP(.revSyn,startWord,startPart,0,,leafSyntax,level,startWord,endWord,chap,verse,startPart,startPart,lvl2,wrd20,wrd2,mismatchCnt)
 ... Q:((level+1)<lvl1)  ; don't need to look that far out
 ... ; add parens on first and last word of section, and syntax
 ... I startWord<minWord d  ; add ...
 .... d aSP(.revSyn,minWord,,"R",1,,level,startWord,endWord,chap,verse,startPart,endPart,lvl2,wrd20,wrd2,mismatchCnt)
 ... E  d aSP(.revSyn,startWord,startPart,"R",,,level,startWord,endWord,chap,verse,startPart,endPart,lvl2,wrd20,wrd2,mismatchCnt)
 ... I endWord>maxWord d
 .... d aSP(.revSyn,maxWord,,"L",1,syntax,level,startWord,endWord,chap,verse,startPart,endPart,lvl2,wrd20,wrd2,mismatchCnt)
 ... E  d aSP(.revSyn,endWord,endPart,"L",,syntax,level,startWord,endWord,chap,verse,startPart,endPart,lvl2,wrd20,wrd2,mismatchCnt)
 ;
 d add("<div class='verse-container'>")
 ;
 s txt="B'reishis "_chap_":"_verse_" "_$$zconvert^mkrutl(wrds,"O","UTF8")
 d add(txt)
 ; Mismatch selection with radio buttons if any
 i mismatchCnt>0 d
 . i mismatchCnt=1 d
 .. s mismatchData=mismatches(1)
 .. s lvl1=$p(mismatchData,"^",1),wrd10=$p(mismatchData,"^",2),wrd1=$p(mismatchData,"^",3)
 .. s lvl2=$p(mismatchData,"^",4),wrd20=$p(mismatchData,"^",5),wrd2=$p(mismatchData,"^",6)
 .. s txt="<div class='mismatch-selector'>"
 .. s txt=txt_"<div class='mismatch-data mismatch-1'>Mismatch: Trop branch words "_wrd10_" - "_wrd1_", "
 .. s txt=txt_"<span class='verse-trop' data-words='"_wrd10_"-"_wrd1_"'>"_$p(wrds,sp,wrd10)_" - "_$p(wrds,sp,wrd1)_"</span>"
 .. s txt=txt_". Syntax branch words "_wrd20_" - "_wrd2_", "
 .. s txt=txt_"<span class='verse-syntax' data-words='"_wrd20_"-"_wrd2_"'>"_$p(wrds,sp,wrd20)_" - "_$p(wrds,sp,wrd2)_"</span>.</div>"
 .. s txt=txt_"</div>"
 .. d add($$zconvert^mkrutl(txt,"O","UTF8"))
 . e  d
 .. s txt="<div class='mismatch-selector'>Select Mismatch:<br>"
 .. f mismatchIdx=1:1:mismatchCnt d
 ... s mismatchData=mismatches(mismatchIdx)
 ... s lvl1=$p(mismatchData,"^",1),wrd10=$p(mismatchData,"^",2),wrd1=$p(mismatchData,"^",3)
 ... s lvl2=$p(mismatchData,"^",4),wrd20=$p(mismatchData,"^",5),wrd2=$p(mismatchData,"^",6)
 ... s checked=$s(mismatchIdx=1:" checked",1:"")
 ... s txt=txt_"<div class='mismatch-data mismatch-"_mismatchIdx_"'>"
 ... s txt=txt_"<span class='mismatch-label'>Mismatch "_mismatchIdx_": Trop "_wrd10_"-"_wrd1_", Syntax "_wrd20_"-"_wrd2_"</span>"
 ... s txt=txt_"<input type='radio' name='mismatch-select-"_chap_"-"_verse_"' id='mismatch-"_mismatchIdx_"-"_chap_"-"_verse_"' value='"_mismatchIdx_"' data-trop='"_wrd10_"-"_wrd1_"' data-syntax='"_wrd20_"-"_wrd2_"' "_checked_" style='margin-left: 10px;'>"
 ... s txt=txt_"</div>"
 .. s txt=txt_"</div>"
 .. d add($$zconvert^mkrutl(txt,"O","UTF8"))
 ;
 d add("<div class='table-container'>")
 ; Determine how many words per segment dynamically based on total words and syntax complexity
 ; Aim for segments of around 10 words, but reduce if there are many syntax elements per word
 S totalWords=maxWord-minWord+1
 ; Calculate complexity based on number of syntax elements
 S complexity=0
 F i=minWord:1:maxWord D
 . S j="" F  S j=$o(revSyn(i,j)) q:j=""  D
 .. F k="L",0,"R" I $D(revSyn(i,j,k)) D
 ... S cnt=$G(revSyn(i,j,k,0),0)
 ... S complexity=complexity+cnt
 ; Adjust segment size based on total words and complexity
 S avgComplexityPerWord=$S(totalWords>0:complexity/totalWords,1:1)
 S segmentSize=$S(totalWords>30:15,totalWords>15:10,1:8)
 I avgComplexityPerWord>2 S segmentSize=$S(segmentSize>10:segmentSize-2,1:segmentSize-1)
 I avgComplexityPerWord>4 S segmentSize=$S(segmentSize>8:segmentSize-2,1:segmentSize-1)
 S segmentSize=$S(segmentSize<5:5,1:segmentSize) ; Ensure minimum segment size
 S currentWord=minWord
 S segmentCount=0
 F  Q:currentWord>maxWord  D
 . S segmentEnd=currentWord
 . S segmentStart=$S(currentWord+segmentSize-1>maxWord:maxWord,1:currentWord+segmentSize-1)
 . S segmentCount=segmentCount+1
 . d add("<table class='segment-table' data-segment='"_segmentCount_"'>")
 . 
 . ; Row 1: Words
 . d add("<tr>")
 . s rowWords=""
 . F i=segmentStart:-1:segmentEnd D
 .. S word=posuk(i) ; number of characters
 .. S class=""
 .. i mismatchCnt>0 d
 ... f mismatchIdx=1:1:mismatchCnt d
 .... s mismatchData=mismatches(mismatchIdx)
 .... s wrd10=$p(mismatchData,"^",2),wrd1=$p(mismatchData,"^",3)
 .... s wrd20=$p(mismatchData,"^",5),wrd2=$p(mismatchData,"^",6)
 .... i i>=wrd10,i<=wrd1 s class=$s(class="": "", 1: class_",")_"trop-mismatch-"_mismatchIdx
 .... i i>=wrd20,i<=wrd2 s class=$s(class="": "", 1: class_",")_"syntax-mismatch-"_mismatchIdx
 .. S rowWords = rowWords _ "<td data-word='"_i_"' class='"_class_"'>"_word_"</td>"
 . d add($$zconvert^mkrutl(rowWords,"O","UTF8"))
 . d add("</tr>")
 . 
 . ; Row 2: trops - build right-to-left to match word order
 . d add("<tr>")
 . s rowTrops="" ; build string right-to-left
 . F i=segmentStart:-1:segmentEnd D
 .. S tropL=$g(revTrops(i,"L")),trop=$g(revTrops(i)),tropR=$g(revTrops(i,"R")),tropClass="verse-trop"
 .. i mismatchCnt>0 d
 ... f mismatchIdx=1:1:mismatchCnt d
 .... s mismatchData=mismatches(mismatchIdx)
 .... s wrd10=$p(mismatchData,"^",2),wrd1=$p(mismatchData,"^",3)
 .... i i>=wrd10,i<=wrd1 s tropClass=tropClass_" mismatch-trop-"_mismatchIdx
 .. S rowTrops = rowTrops _ "<td><span class='"_tropClass_"'>"_tropL_$zstrip(trop,"<W")_tropR_"</span></td>"
 . d add(rowTrops)
 . d add("</tr>")
 . 
 . ; Row 3: Syntax
 . d add("<tr>")
 . F i=segmentStart:-1:segmentEnd D  ; leaf syntax
 .. d add("<td>")
 .. S j="" F  S j=$o(revSyn(i,j),-1) q:j=""  d  ; word-part
 ... S partTxt=""
 ... F k="L",0,"R" i $d(revSyn(i,j,k)) d  ; leaf or syntax branch ends
 .... S class=$s(k=0:"syntax-part",k="L":"branch-end",k="R":"branch-start",1:"")
 .... i mismatchCnt>0,k'="R",k'="L" d
 ..... f mismatchIdx=1:1:mismatchCnt d
 ...... s mismatchData=mismatches(mismatchIdx)
 ...... s wrd20=$p(mismatchData,"^",5),wrd2=$p(mismatchData,"^",6)
 ...... i i>=wrd20,i<=wrd2 s class=class_" mismatch-syntax-"_mismatchIdx
 .... I k="L" F cnt=$g(revSyn(i,j,k,0)):-1:1 d  ; maybe several on one part, esp. ('s
 ..... S part=revSyn(i,j,k,cnt)
 ..... S partTxt=partTxt_part
 .... E  F cnt=1:1:$g(revSyn(i,j,k,0)) d  ; maybe several on one part, esp. ('s
 ..... S part=revSyn(i,j,k,cnt)
 ..... S partTxt=partTxt_part
 ... d add(partTxt)
 .. d add("</td>")
 . d add("</tr>")
 . d add("</table>")
 . S currentWord=segmentStart+1
 d add("</div>") ; end table-container
 ; Removed the mismatch-info section as it's now handled above with radio buttons
 d add("</div>") ; end verse-container
 d add("<br />")
 q
 ;
getTaam(posuk,i) ; for ith word
 n taam,unicode
 s taam=""
 s unicode="" f  s unicode=$o(posuk(i,"ta'am",unicode)) q:unicode=""  d
 . q:unicode="mult"  ; multiple ta'amim on one word flag
 . q:unicode="missing"
 . s taam1=chars(unicode,"name"),taam=taam_$s(taam="":"",1:" ")_taam1
 q taam
 ;
aTP(revTrops,wordIdx,direction,dots,level,startWord,endWord,chap,verse,mismatchLevel,mismatchStart,mismatchEnd,mismatchCnt)	; add left/right paren. revTrops array in/out by reference
 n dottxt,txt1,id,class
 s dottxt="" i $g(dots) s dottxt="..."
 s id="trop-"_chap_"-"_verse_"-"_mismatchCnt_"-"_level_"-"_startWord_"-"_endWord_"-"_direction
 s class = $s(direction="L":"branch-end",direction="R":"branch-start",1:"")_" trop-level-"_level
 i (level=mismatchLevel) & (startWord=mismatchStart) & (endWord=mismatchEnd) s class = class_" mismatch-pair"
 i direction="L" s revTrops(wordIdx,"L") = "<span id='"_id_"' class='"_class_"'>("_dottxt_"</span>"_$g(revTrops(wordIdx,"L"))
 i direction="R" s revTrops(wordIdx,"R") = $g(revTrops(wordIdx,"R"))_"<span id='"_id_"' class='"_class_"'>"_dottxt_")</span>"
 q
 ;
aSP(revTrops,wordIdx,partIdx,direction,dots,syntax,level,startWord,endWord,chap,verse,startPart,endPart,mismatchLevel,mismatchStart,mismatchEnd,mismatchCnt)	; add left/right paren., and syntax just next to left paren (on last word in section)
 ; leaves and syntax are (somewhat) independent: leaves never need ( ), syntax always does.
 n cnt,dottxt,txt1,id,class
 s partIdx=$g(partIdx)
 i partIdx="" s partIdx=$s(direction="L":1000,direction="R":0,1:"") ; use 0 or 1000 if not specified to make it the last one
 s syntax=$g(syntax)
 s dottxt="" i $g(dots) s dottxt="..."
 s id="syntax-"_chap_"-"_verse_"-"_mismatchCnt_"-"_level_"-"_startWord_"-"_endWord_"-"_startPart_"-"_endPart_"-"_direction
 s class = $s(direction="L":"branch-end syntax-level-"_level,direction="R":"branch-start syntax-level-"_level,1:"syntax-part")
 i (direction="L"!(direction="R")) & (level=mismatchLevel) & (startWord=mismatchStart) & (endWord=mismatchEnd) s class = class_" mismatch-pair"
 i direction=0 s (cnt,revSyn(wordIdx,partIdx,0,0))=$g(revSyn(wordIdx,partIdx,0,0))+1,revSyn(wordIdx,partIdx,0,cnt)="<span class='syntax-part'>"_syntax_"</span>"
 i direction="L" s (cnt,revSyn(wordIdx,partIdx,"L",0)) = $g(revSyn(wordIdx,partIdx,"L",0))+1,revSyn(wordIdx,partIdx,"L",cnt)="<span id='"_id_"' class='"_class_"'>("_dottxt_syntax_"</span>"
 i direction="R" s (cnt,revSyn(wordIdx,partIdx,"R",0))=$g(revSyn(wordIdx,partIdx,"R",0))+1,revSyn(wordIdx,partIdx,"R",cnt) = "<span id='"_id_"' class='"_class_"'>"_dottxt_")</span>"
 q
 ;
add(x)	;
	n cnt,glb1
	s glb1="^TMP("_$j_",""out"")"
	s (cnt,@glb1@(0))=$g(@glb1@(0))+1
	s @glb1@(cnt)=x
	q
	;
includeFile(filename) ;
 n file,i,inary,subpath
 s subpath="QR\QRCode\out\includes\"
 d readin1 ; loads inary array
 f i=1:1 q:'$d(inary(i))  d
 . d add(inary(i))
 q
readin1 ; Read single file
 k inary
 d getfile^mkrutl(filename,.inary,subpath)
 q
