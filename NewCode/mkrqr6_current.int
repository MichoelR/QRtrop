mkrqr6 ; mkr 04/17/2025; kriah (קריה) and trope (טעמים) - loading BHSA database ^torah2
 ; Code augmented by Grok (xAI), April 2025, for trope handling, grammatical parts, and BHSA parsing
 ; Loads Leningrad Codex data from BHSA single file, producing ^torah2 matching ^torah
 ; Includes trope hierarchy ("lvls") and grammatical data ("grms", "grm", "slvls")
 ;
fullload ; Main entry point
 n glb2
 s glb2="^mkr1(""grm"")"
 k @glb2
 d readin,load0 ; Load into ^mkr1("grm")
 k ^torah2 m ^torah2=@glb2 ; Final storage
 q
 ;
readin ; Load BHSA file
 n filenm
 s filenm="grammar_v_trop-v3.0.txt" d readin1
 q
readin1 ; Read single file
 n mkr,subpath
 s subpath="QR\"
 d getfile^mkrutl(filenm,.mkr,subpath)
 k ^mkr1("grm0") m ^mkr1("grm0")=mkr
 q
 ;
load0 ; Parse into ^torah2
 n bookE,bookL,bookn,c,chars,glb0,glb2,ii,jj,lvlI,nn,pieces,sefer,syntax,syntaxI,t,x
 n i,j,curBook,vcnt,pidx
 s t=$c(9),c=",",sp=" ",b1="[",b2="]",q1="'",U="^"
 s nn=0
 f xx="wrds","wrdparts","grms2","wrdns0","grmns","functionalParents","id","mothers","relas","typs" s nn=nn+1,pieces(nn)=xx
 m chars=^mkr4("chars") m syntax=^mkr4("syntax")
 m syntaxI=syntax(0,"I") m lvlI=syntax(0,"lvlI")
 s glb0="^mkr1(""grm0"")",glb2="^mkr1(""grm"")"
 ; Initialize book and verse counters
 s i=0,curBook="",vcnt=0,pidx=0
 ; Here all the data is from a single file; we'll have to look for the book separately
 ; So jj here is the row/"verse" for the entire Tanach
 f jj=1:1 q:'$d(@glb0@(jj))  d load1 ; one verse
 ; Finalize last book
 i curBook'="" s @glb2@(i,0)=vcnt
 q
load1 ; Process one verse
 n bookE,bookL,bookn,chap,chapp,curBook,errf,grmI,grmI1,grms,grmns,grms2,id,j,k,multf,nn
 n section,pos,SA,SA1,slvls,trops,tropes,tropns,tropns0,trops2,tropeName,tropePos
 n uniCode,verse,wrds,wrdns,wrdns0,y,functionalParents,relas,typs,pstart,pnext
 s x=@glb0@(jj) q:x=""
 s errf=0,tropes2=""
 s pstart=0 ; counter for parts of words
 i $l(x,t)'=10 d error("Row "_jj_" has wrong number of tab pieces") q
 ; see in validatePieces for nature and structure of the pieces
 d validatePieces(x,.pieces,.wrds,.wrdparts,.grms2,.wrdns0,.grmns,.functionalParents,.id,.mothers,.relas,.typs) ; clean string, make sure the pieces are the right lengths
 q:errf
 d getPos(grmns,.pos) ;  create sequential position array for syntax string
 ; now convert wrdns to use positions from there rather than ids
 f k=1:1:$l(wrdns0,c) s n=$p(wrdns0,c,k),jpos=$g(pos(n)),$p(wrdns,c,k)=jpos
 f k=1:1:$l(tropns0,c) s n=$p(tropns0,c,k),jpos=$g(pos(n)),$p(tropns,c,k)=jpos
 s bookL=$p(id,c),chap=+$p(id,c,2),verse=+$p(id,c,3)
 ; Map BHSA book names to book numbers
 d getBookN(bookL,.bookn,.sefer,.bookE,.section) ; includes section=2 say for Samuel-II
 i bookn=0 d error("Unknown book: "_book) q
 ; Handle book change
 i bookn'=i d
 . i i>0 s @glb2@(i,0)=vcnt ; Store total verse count for previous book
 . s i=bookn,vcnt=0,curBook=bookL
 . s @glb2@(i,"sefer")=sefer
 . s @glb2@(i,"sefer","eng")=bookE
 . s @glb2@(i,"sefer","latin")=bookL
 s (j,vcnt)=vcnt+1 ; New total verse number, not by chapter
 s chapp=$s(section:section_" "_chap,1:chap)
 s verseText="",tropes2="",wordCount=$l(wrds,c)
 ; fix: zinor into zarqa
 ;  an old mistake in Unicode http://www.mechon-mamre.org/c/hr/unicode.htm
 ;  tsinor is actually the character used for both our tsinor and zarqa
 i ((bookn<26)!(bookn>28)),wrds[$c(1454) d  ; except in EMeT sefarim
 . s wrds=$tr(wrds,$c(1454),$c(1432))
 . s trops=$tr(trops,$c(1454),$c(1432)) ; we don't actually use this
 ; make sure the SOF PASUK ($c(1475) is included
 i $e(wrds,$l(wrds))'="׃" s wrds=wrds_"׃"
 ; okay, one word at a time through the posuk
 f k=1:1:wordCount d load2 ; process each word. One "word" can be connected by maqaf
 ;
 ; verse-level data; Store in ^torah2
 s tropes2=$e(tropes2,2,*)
 s @glb2@(i,j)=verseText
 s @glb2@(i,j,0)=wordCount
 s @glb2@(i,j,"chap")=chap
 s:section @glb2@(i,j,"chapp")=chapp ; like "2 7" for chap. 7 of Samuel-II
 s:section @glb2@(i,j,"section")=section ; 2 for Samuel-II
 s @glb2@(i,j,"verse")=verse
 s @glb2@(i,j,"swhole")=$tr(verseText,"֑֖֛֢֣֤֥֦֧֪֚֭֮֒֓֔֕֗֘֙֜֝֞֟֠֡֨֩֫֬֯׃")
 s @glb2@(i,j,"tropes")=tropes2 ; english for all trope in the verse
 s @glb2@(i,j,"lvllst")=""
 s @glb2@(i,j,"grms")=grms2
 m @glb2@(i,j,"grmI")=grmI
 d ldTropeLvls(i,j,.chars)
 d ldSyntaxLvls(i,j)
 s @glb2@("cvE",i,+section,chap,verse)=j
 s @glb2@("grmI2",$e(grms2,1,450),j)=""
 q
 ;
load2 ; single word
 n p,part,parts,tag,grmPos,pnext
 s word=$p(wrds,c,k)
 s verseText=verseText_$s(k=1:"",1:" ")_word
 ; get trope by hand rather than relying on "trops" passed in
 d gettrope(word,.tropes,.multf) ; type and position in word - may be more than one per word
 ; handle missing trope
 i '$d(tropes) d
 . s @glb2@(i,j,k,"ta'am","missing")=$p(tropns,c,k) ; Store missing trope with position
 . s @glb2@("missingTropes",i,j,k)=word ; Log for review
 . ; Optional: Infer Tipeha (disabled by default)
 . i 0 d
 .. s tropes(1430)=$p(tropns,c,k),tropeName="TIPEHA",multf=0
 .. s @glb2@("missingTropes",i,j,k,"inferred")="TIPEHA"
 s uniCode="" f  s uniCode=$o(tropes(uniCode)) q:uniCode=""  d
 . s tropePos=tropes(uniCode) ; position in word
 . s tropeName=$g(chars(uniCode,"name")),tropes2=c_tropeName_tropes2
 . s @glb2@(i,j,k,"ta'am",uniCode,tropePos)=""
 i multf s @glb2@(i,j,k,"ta'am","mult")="" ; multiple
 s @glb2@(i,j,k)=word
 ; Process grammatical parts (wrdparts)
 ; Note that grms2 has more pieces than wrdparts, not every syntax is text.
 s pstart=$s(k=1:pidx+1,1:pstart) ; Start id in grmns for this word's parts
 ; these are cumulative, increasing from word to word, verse to verse.
 s pnext=$p(wrdns0,c,k) ; End index for this word's parts
 i pstart<=pnext f p=pstart:1:pnext d  ; walk through parts
 . s pp=p-pidx ; Relative part index (1-based)
 . s part=$p(wrdparts,c,pp)
 .; i part'="" d  ; now allow empty parts
 . s @glb2@(i,j,k,"grm",pp,"part")=part
 . ; Map tag using grmns, check for word-level tag (lowercase)
 . s grmPos=$g(pos(p)) i grmPos'="" d
 .. s tag=$p(grms2,c,grmPos)
 .. i tag?1l.l d ; Only lowercase tags contain text
 ... s @glb2@(i,j,k,"grm",pp,"tag")=tag
 ... s grmI(pp)=k ; reverse index for verse, to find part in words given its overall wrdparts count
 ... s grmI1(p)=k_c_pp ; temp reverse index to help look up part given its id
 i pstart<=pnext s @glb2@(i,j,k,"grm",0)=pnext-pstart+1 ; Store part count
 s pstart=pnext+1 ; update for next word
 ; Update global part index for next verse
 i k=wordCount s pidx=pnext
 q
 ;
validatePieces(inStr,pieces,wrds,wrdparts,grms2,wrdns0,grmns,functionalParents,id,mothers,relas,typs)	; cleans and adjusts input data,
 ; and makes sure that each section is the right length.
 ; pieces array is passed in by reference. All the later parameters are passed back by reference.
 ;
 ; documentation of "pieces" sections. Comes in as string x with this tab-delimited format:
 ; [piece1 tab piece2 tab ... tab piece8]
 ; Each piece is comma-delimited, in some each element has '', others not. We'll strip out ' and spaces.
 ; Output is ten elements in pieces array, pieces(1),...,pieces(10)
 ;
 ; piece descriptions
 ;1: wrds. List of words in the verse, in order. If two are connected by maqaf, so they have only one ta'am,
 ;         they are included in a single word, like על-פני in the first verse.
 ;2: wrdparts. List of syntactical parts of the sentences, pieces of each word, in order.
 ;         Some of them can actually be empty, like בָּאָֽרֶץ contains three parts, "in" "the" "land",
 ;         and there is no letter corresponding to "the".
 ;3: grms2. List of syntax of the sentence, a tree in reverse polish notation, including the syntax
 ;         of the "wrdparts" above, like "prep" "art" "subs" for the above example, but also including
 ;         higher level groupings like phrase, clause, sentence.
 ;         The number of lowest level syntaxes (otype="word"), should match the length of wrdparts.
 ;4: wrdns0. bhsa id for the _last_ wrdpart in each of the words in wrds, so we can use this to add wrdparts
 ;         together to match each word. Length should match wrds.
 ;5: grmns. bhsa id for each of the syntaxes in grms2. Length should match grms2, and number of the ids that
 ;         match wrdparts should match the length of wrdparts.
 ;6: functionalParents. Similar to grmns, but this is the functionalParent field for each of the syntax pieces. So each
 ;         of these, if it exists, points to something else in grmns. This is what builds the syntax tree.
 ;7: id. Contains metadata on the posuk, like book, chapter, and verse.
 ;8: functionalParents. List of mother node IDs for each syntax element in grms2.
 ;9: relas. List of relation types for each syntax element in grms2.
 ;10: typs. List of type attributes for each syntax element in grms2.
 ;
 n kk,lngrms,nn,NO,NO1,SA,SA1,x,y
 s (wrds,wrdparts,grms2,wrdns0,grmns,functionalParents,id,mothers,relas,typs)=""
 f nn=1:1:10 d  q:errf
 . s y=$p(inStr,t,nn)
 . ; Normalize Unicode quotes to ASCII
 . s y=$tr(y,$c(8216,8217,8220,8221),$c(39,39,34,34))
 . ; Relaxed pattern: expect [...,...]
 . i y'?1"["1.e1"]",'$l(y,",") d error("Row "_jj_", piece "_nn_" is malformed: "_$e(y,1,250)) q
 . s y=$tr(y,"[]' ") ; Strip [ ], ', space - just leaves comma-delimited now
 . s @pieces(nn)=y ; assign all the local variables
 ;
 ; okay, check length compatibility
 i $l(wrds,c)'=$l(wrdns0,c) d error("Row "_jj_", length of wrds '= length of wrdns0: "_wrds_"|"_wrdns0) q
 i $l(grms2,c)'=$l(grmns,c) d error("Row "_jj_", length of grms2 '= length of grmns: "_grms2_"|"_grmns) q
 i $l(functionalParents,c)'=$l(grmns,c) d error("Row "_jj_", length of functionalParents '= length of grmns: "_functionalParents_"|"_grmns) q
 ;
 ; shorten sentence_atom terms and make them upper-case: only otype='word' leaf nodes should be lower-case.
 s SA="sentence",SA1="SENT"
 f k=1:1:$l(grms2,c) i $p(grms2,c,k)=SA s $p(grms2,c,k)=SA1
 s NO="subs",NO1="noun"
 f k=1:1:$l(grms2,c) i $p(grms2,c,k)=NO s $p(grms2,c,k)=NO1
 ;
 s lngrms=0 f kk=1:1:$l(grms2,c) d
 . s z=+$p(functionalParents,c,kk),$p(functionalParents,c,kk)=z ; turn into integer (7.0 --> 7), get rid of NaN --> 0
 . s ns=$p(grms2,c,kk) i ns'?.l q  ; not lower case
 . s lngrms=lngrms+1
 i lngrms'=$l(wrdparts,c) d error("Row "_jj_", word pieces in grms2 '= length of wrdparts: "_grms2_"|"_wrdparts) q
 q
 ;
gettrope(word,tropes,multf) ; finds type and position of trope in word, array returned by reference
 ; all trope are Unicode between U+0591 and U+05AE (U+#1425 through U+#1454),
 ;  or sof pasuk = 05C3 = #1475 and paseq = 05C0 = #1472 ("|")
 ; mkr 12/02/20 - we also need to deal with וּשְׁתַּ֨יִם֙, qadma and pashta on one word -
 ;  and only the pashta is real. pashta = #1433, qadma = #1448
 ; mkr 04/21/25 - might also need to deal with other doubled trope, in some printings?
 n cnt,char,mm,ln,uni
 k tropes
 s cnt=0
 s ln=$l(word)
 f mm=1:1:ln d  ; skip everything but trope
 . s char=$e(word,mm),uni=$a(char)
 . q:uni<1425  q:(uni>1454)&(uni'=1475)&(uni'=1472)
 . ; get rid of qadma if there's a pashta (which is always last)
 . i uni=1433 d
 .. i $d(tropes(1448)) k tropes(1448) s cnt=cnt-1
 .. i $d(tropes(1433)) k tropes(1433) s cnt=cnt-1 ; just in case there were two pashtas instead
 . s tropes(uni)=mm,cnt=cnt+1
 s multf=(cnt>1)
 q
 ;
ldTropeLvls(bookn,versen,chars) ; Compute trope hierarchy
 n done,found,i,j,k,kk,k2,k3,lvl,lvls,lvl2,node,nodehdr,psk,sbsc,tlvls,tlvlsI,trh,tropes,txt
 k psk,lvls,trh
 s psk(0)=@glb2@(bookn,versen,0)
 s tropes=""
 f k=1:1:psk(0) d
 . s lvl=$$getWordLvl(bookn,versen,k,.tr,.trE,.txt,.chars)
 . s psk(k,"lvl")=lvl
 . i lvl'="" s psk(k,"lvl","trope")=trE
 . s psk(k,"trope2")=trE ; save regardless
 . s psk(k,"txt")=txt
 . s tropes=tropes_$s(tropes="":"",1:",")_trE
 f k=psk(0):-1:1 d
 . s lvl=$g(psk(k,"lvl"))
 . i lvl'="" s lvls(lvl,k)=""
 f lvl=1:1:4 d
 . s k="" f  s k=$o(lvls(lvl,k),-1) q:k=""  d
 .. s k2=""
 .. f lvl2=lvl:-1:1 d
 ... s k3=$o(lvls(lvl2,k),-1)
 ... i k2'="",k3<k2 q
 ... s k2=k3
 .. s k2=k2+1
 .. s @glb2@(bookn,versen,k,"realmend",lvl)=k2
 .. s lvls(lvl,k)=k2
 .. s @glb2@(bookn,versen,k2,"realmstart",lvl)=""
 .. s tropesHere=$p(tropes,",",psk(0)-k+1,psk(0)-k2+1)
 .. s @glb2@(bookn,versen,k,"trH")=tropesHere
 m @glb2@(bookn,versen,"lvls")=lvls
 ; okay, now build a bigger structure than lvls with everything included.
 ; the top node of a realm is the trop of the last word in the realm.
 s nodehdr="tlvls("
 f lvl=1:1:4 d
 . s k="" f  s k=$o(lvls(lvl,k)) q:k=""  d
 .. s k1=""
 ..; okay, we need to find the node "above" it, one level up, if we're not at top
 .. i lvl>1 d
 ... s k1=$o(lvls(lvl-1,k-1)) ; last word in the node above
 .. d ldNode(k,k1,lvl,.psk,.tlvls,.tlvlsI) ; okay now set this node in place
 .. s found(k)="" ; so we won't do it again later
 ; We _also_ need to load the משרתים, connecting trop, which were not found in lvls before.
 ; We'll go through all the words in the verse, skip the ones we did already. משרתים are always
 ;  the last trop before a מפסיק, so we can do them now. We just need to look for the _next_ מפסיק,
 ;  anywhere in lvls.
 f k=1:1:psk(0) d  ; look for words we missed
 . q:$d(found(k))  ; already included (i.e., it's a מפסיק).
 . s done=""
 . f lvl=4:-1:1 d  q:done ; lower levels will always be shorter
 .. s kk=$o(lvls(lvl,k-1)) q:'kk ; is there a realm on this level past our word?
 .. i k<lvls(lvl,kk) q  ; lvls(lvl,kk) is the _first_ word in the realm. Are we inside?
 .. d ldNode(k,kk,0,.psk,.tlvls,.tlvlsI) ; okay, found it
 .. s done=1,found(k)=""
 ;
 m @glb2@(bookn,versen,"tlvls")=tlvls
 m @glb2@(bookn,versen,"tlvlsI")=tlvlsI
 q
ldNode(k,kk,lvl,psk,tlvls,tlvlsI) ; add new data to tlvls and tlvlsI for this node k, parent is kk
 ; psk,tlvls,tlvlsI passed in and out by reference
 n cnt,k1,node,sbsc
 s nodehdr="tlvls("
 s node="tlvls",sbsc=""
 i kk d  ; find path for node above it, if we aren't at the top
 . s sbsc=tlvlsI(kk)
 . s node=nodehdr_sbsc_")"
 s (cnt,@node@(0))=$g(@node@(0))+1
 s @node@(cnt)=psk(k,"txt")
 s @node@(cnt,0,"k")=k
 i lvl s @node@(cnt,0,"lvl")=lvl ; משרתים will have lvl=0
 s @node@(cnt,0,"trope")=psk(k,"trope2")
 s tlvlsI(k)=$s(sbsc="":cnt,1:sbsc_c_cnt) ; reverse index to find chain of subscripts leading to this part
 q
 ;
getWordLvl(bookn,versen,k,tr,trE,txt,chars) ; Trope level for one word and other metadata
 n done,i,j,k2,lvl,lvl0,lvl1,PASEK,REVIA,PASHTA,KADMA,tr0,tr1,trope
 s PASEK=1472,REVIA=1431,PASHTA=1433,KADMA=1448
 s tr="",trE=""
 k trope m trope=@glb2@(bookn,versen,k,"ta'am")
 s lvl="",tr0=""
 s txt=@glb2@(bookn,versen,k)
 i $d(trope("missing")) s lvl=0 q lvl ; Skip missing tropes in hierarchy
 f  s tr0=$o(trope(tr0)) q:tr0=""  q:tr0'?1N.N  d
 . q:$g(chars(tr0,"type"))'="trope"
 . q:tr0=KADMA&$d(trope(PASHTA))
 . s lvl0=$g(chars(tr0,"lvl"))
 . i tr0=PASEK d
 .. s done=0,lvl0=""
 .. f k2=k+1:1:psk(0) d  q:done
 ... s lvl1=$g(psk(k2,"lvl")),tr1=$g(psk(k2,"lvl","trope"))
 ... q:tr1=""  q:tr1=PASEK
 ... s done=1
 ... i tr1=REVIA s lvl0=4
 . i lvl0'="" s lvl=$s(lvl="":lvl0,1:$s(lvl<lvl0:lvl,1:lvl0))
 . s tr="|"_tr0_tr
 . s trE="|"_$g(chars(tr0,"name"))_trE
 s tr=$e(tr,2,*),trE=$e(trE,2,*)
 q lvl
 ;
getPos(grmns,pos) ; Position index
 n c,glen,k,n
 s c=","
 k pos
 s glen=$l(grmns,c)
 f k=1:1:glen s n=$p(grmns,c,k),pos(n)=k,pos(0,"I",k)=n
 ;zw pos
 q
 ;
getBookN(bookL,bookn,bookH,bookE,section) ; Map BHSA book names to book numbers
 n bookn1
 s (bookH,bookE,bookn,section)=""
 ; English list, including I and II like Samuel-I and Samuel-II
 s bookn1=$g(^mkr4("books","I",bookL)) q:'bookn1
 s bookn=$g(^mkr4("books",bookn1,"cnt")) q:'bookn  ; Torah list, like just Shmuel
 s section=$g(^mkr4("books",bookn1,"part")) ; usually not there, but "2" for Samuel-II
 s bookE=^mkr4("sefer",bookn,"eng")
 s bookH=^mkr4("sefer",bookn)
 q bookn
 ;
ldSyntaxLvls(bookn,versen) ; Compute syntax tree levels for a verse using functionalParents, preserving nesting
 ; Input: bookn, versen (indices for ^mkr1("grm",bookn,versen); uses wrds, grms2, wrdns, grmns, functionalParents from load1 scope)
 ; Output: Sets ^mkr1("grm",bookn,versen,"slvls",level,word)=nodeType
 ;         Sets ^mkr1("grm",bookn,versen,word,"pieceNodes")=nodeList
 n cnt,fslvls,fslvls0,grm,grmn,i,j,k,kk,lvl,node,nodehdr,parentn,piece,sbsc,sbsc1,slvls,slvlsI,slvlsI1,txt,wp
 s nodehdr="slvls(" ; we'll build the node location with this plus the index
 ; RPN, so children are on the right of parents. As we go, we store the location of the parent in the tree.
 f k=1:1:$l(grms2,c) d
 . s grm=$p(grms2,c,k),grmn=$p(grmns,c,k),parentn=$p(functionalParents,c,k)
 . s node="slvls",sbsc=""
 . i parentn,$g(slvlsI1(parentn)) d
 .. s sbsc=slvlsI1(parentn) ; temp array, should be there already, no unrecognized parents
 .. s node=nodehdr_sbsc_")" ; location of parent, like "slvls(1,2)"
 .; add our new node just below it
 . s (cnt,@node@(0))=$g(@node@(0))+1
 .; look up part in word section. kk = word #, wp = overall wrdpart #
 . d getWrdPart(grmn,bookn,versen,.kk,.wp,.txt,.tag)
 .; if the part has text (for leaves), include that here too
 . i txt'="" s @node@(cnt,0,"part")=txt,@node@(cnt,0,"tag")=tag
 . s @node@(cnt)=grm
 . s sbsc1=$s(sbsc="":cnt,1:sbsc_c_cnt)
 . i wp s @node@(cnt,0,"wp")=wp ; enable look up in the word section. use grmI to find kk word #.
 . i wp s slvlsI(wp)=sbsc1 ; reverse index for wrdparts to find chain of subscripts leading to this part
 . s slvlsI1(grmn)=sbsc1 ; temp array that includes all syntax elts
 .;
 .; also set _flat_ array fslvls for simpler queries
 .; as with lvls for trop, this includes information on when each section begins, and ends.
 .; So when we hit a wordpart (wp), which will be in order,
 .;  we send its info to each node above, so each of them
 .;  can identify first and last.
 . i wp d  ; leaf
 ..; first do the leaf itself
 .. s fslvls0(sbsc1,"first")=kk_U_wp,fslvls0(sbsc1,"last")=kk_U_wp,fslvls0(sbsc1,"txt")=txt,fslvls0(sbsc1,"tag")=tag
 .. i sbsc f lvl=1:1:$l(sbsc,c) d  ; all its ancestors
 ... s sbsc1=$p(sbsc,c,1,lvl) ; subscript for that higher level
 ... s node=nodehdr_sbsc1_")",fslvls0(sbsc1,"grm")=@node
 ... s fslvls0(sbsc1,"last")=kk_U_wp ; even if defined before, increase it
 ... i '$d(fslvls0(sbsc1,"first")) s fslvls0(sbsc1,"first")=kk_U_wp ; first time only
 ;
 ; now go back through temp fslvls0 and build fslvls
 s sbsc="" f  s sbsc=$o(fslvls0(sbsc)) q:sbsc=""  d
 . s lvl=$l(sbsc,c)
 . s x1=fslvls0(sbsc,"first"),x2=fslvls0(sbsc,"last"),txt=$g(fslvls0(sbsc,"txt")),grm=$g(fslvls0(sbsc,"grm")),tag=$g(fslvls0(sbsc,"tag"))
 . s fslvls(lvl,$p(x2,U),$p(x2,U,2))=x1_U_grm_U_txt_U_tag ; level, last word, last wordpart = 1st word, 1st wordpart
 ;
 m @glb2@(bookn,versen,"slvls")=slvls
 m @glb2@(bookn,versen,"slvlsI")=slvlsI
 m @glb2@(bookn,versen,"fslvls")=fslvls
 q
 ;
getWrdPart(grmn,bookn,versen,kk,pp,txt,tag) ; find part text
 ; last four arguments passed back by reference:
 ; kk is word count, pp is (overall) wrdpart count.
 ; txt & tag are only nonnull if it's a leaf.
 n p
 s (kk,pp,txt)=""
 s p=$g(grmI1(grmn)) q:'p "" ; look up in reverse index for verse
 s kk=$p(p,c),pp=$p(p,c,2)
 s txt=@glb2@(bookn,versen,kk,"grm",pp,"part")
 s tag=@glb2@(bookn,versen,kk,"grm",pp,"tag")
 q
 ;
error(txt) ; Log error
 s @glb2@("log",$i(@glb2@("log")))=txt
 s errf=1
 q
 ;
